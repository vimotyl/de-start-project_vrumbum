Добрый день!
В этом файле прилагаю комментарии по решению и вопросы, которые возникли в процессе выполнения проекта.

В файле solution.sql приложила все скрипты по созданию и заполнению таблиц.
В процессе заполнения я делала выборки, чтобы контролировать,
как загружаются данные. Их тоже оставила, но закомментировала.




< ЧАСТЬ 1 >
КОММЕНТАРИИ К ЗАПУСКУ РЕШЕНИЯ

Все скрипты запустить одной командой не получится,
так как я заполняла таблицу с сырыми данными через терминал.

Поэтому необходимо выполнить три шага:
Шаг 1. Запустить первые два скрипта для создания схемы raw_data и таблицы sales.
Шаг 2. Загрузить данные в таблицу sales через терминал командой:
\copy raw_data.sales FROM '/Users/cars.csv' CSV HEADER NULL 'null';
Шаг 3. Запустить все оставшиеся скрипты.





< ЧАСТЬ 2 >
ОПИСАНИЕ ВЫБРАННОЙ МОДЕЛИ ДАННЫХ

Таблицы:
 * clients - информация о клиентах;
 * origin - информация о странах-производителях автомобилей;
 * brands - информация о брендах автомобилей;
 * models - информация о моделях автомобилей;
 * colors - информация о цветах моделей автомобилей;
 * cars - информация об автомобилях (выбранные модель + цвет);
 * orders - информация о совершенных заказах.



Описание каждой таблицы


1) Таблица clients хранит в себе информацию о клиентах.
Поля: id, service_person_name, appeal, first_name, last_name, status, phone.

Поле id - суррогатный первичный ключ с автоинкрементом.
Поле service_person_name - служебное, куда изначально загружаю полное имя клиента,
а после заполнения всех таблиц делим это поле на четыре отдельных поля:
- first_name (имя)
- last_name (фамилия)
- appeal (обращение, например, Dr., Miss, Mr., Mrs.)
- status (степень/дополнение к имени, например, MD, Jr.)
После разделения полного имени служебное поле service_person_name удаляю.

Поле phone - номер телефона клиента в том виде, в котором он был указан в исходной таблице.
Я отказалась от идеи привести запись номера к единому формату, так как в таблице слишком много вариаций.
Чтобы при преобразовании не потерять данные, я бы уточнила у заказчика, что означает каждый формат записи.
И после этого сделала преобразование к единому формату.




2) Таблица origin хранит в себе информацию о странах-производителях автомобилей.
Поле: country.

Таблица используется как справочник стран.
Поле country - наименование страны, является натуральным первичным ключом.

Суррогатный ключ id не стала добавлять, так как поле country позволяет сразу видеть наименование
страны в связанной таблице с брендом (вместо абстрактного id) и избавиться от дополнительного join,
если нужно получить наименование страны.




3) Таблица brands хранит в себе информацию о брендах автомобилей.
Поля: name, brand_origin.

Таблица используется как справочник брендов авто.
Поле name - наименование бренда, является натуральным первичным ключом.
Поле brand_origin - страна-производитель, внешний ключ ссылается наименование страны таблице origin(country).

Аналогично предыдущей таблице не стала добавлять суррогатный ключ id, 
чтобы сразу получать наименование бренда (name) вместо абстрактного id.





4) Таблица models хранит в себе информацию о моделях автомобилей каждого бренда.
Поля: id, name, brand_name, is_electric_car, gasoline_consumption.

Поле id - суррогатный первичный ключ с автоинкрементом.
Поле name - наименование модели авто (например, 'A3').
Поле brand_name - наименование бренда авто, внешний ключ ссылается на имя бренда в таблице brands(name).
Поле is_electric_car - принимает значение TRUE, если это электромобиль, иначе FALSE.
Поле gasoline_consumption - среднее потребление бензина, литр на 100 км, у электромобилей это значение отсутствует.




5) Таблица colors хранит в себе информацию о возможных цветах моделей автомобилей.
Поле: name.

Таблица используется как справочник цветов автомобилей.
Поле name - название цвета, является натуральным первичным ключом.





6) Таблица cars хранит в себе информацию о конкретных автомобилях (выбранные модель + цвет);
Поля: id, model_id, color_name.


Поле id - суррогатный первичный ключ с автоинкрементом.
Поле model_id - модель авто, внешний ключ ссылается на id модели в таблице models(id).
Поле color_name - цвет авто, внешний ключ ссылается на название цвета в таблице colors(name).




7) Таблица orders хранит в себе информацию о совершенных заказах.
Поля: id, order_date, client_id, car_id, price, discount_percent.


Поле id - суррогатный первичный ключ с автоинкрементом.
Поле order_date - дата совершения покупки.
Поле client_id - номер клиента, внешний ключ ссылается на id клиента в таблице clients(id).
Поле car_id - номер купленного автомобиля, внешний ключ ссылается на id авто в таблице cars(id).
Поле price - полная стоимость заказа, без учета скидки.
Поле discount_percent - скидка в процентах, по умолчанию 0.


В исходных даных указана стоимость заказа с учетом скидки. Это неудобно и неоднозначно.
Например, если скидку в базе изменят, то нужно пересчитывать стоимость со скидкой.
Или если не указан процент скидки, это значит, что ее нет или забыли указать?
Поэтому приняла решение хранить полную стоимость заказа и отдельно процент скидки.
Имея эти данные, при необходимости можно вычислять стоимость со скидкой.





< ЧАСТЬ 3 >
ВОПРОСЫ

1) В каких случаях для текстовых полей необходимо использовать TEXT, а в каких VARCHAR(n),
если у поля нет конкретного ограничения по длине (например, для фамилии / названия бренда)?

Если я верно поняла, TEXT обрабатывать быстрее, так как нет проверки на максимальную длину.
Но при этом в поле типа TEXT можно случайно (или специально) записать очень большой текст, 
где его быть не должно (например, фамилия).

Как делать выбор между этими двумя типами данных?



2) При выполнении проекта в некоторых таблицах я сделала суррогатный первичный ключ id,
но в некоторых (например, цвета, бренды, страны) сделала натуральный первичный ключ name.

Рассуждала так:
если таблица выполняет роль справочника (например, перечислить все необходимые страны),
то удобно, если наименование объекта будет первичным ключом. Так, например, если будем
получать список брендов, то не нужно будет добавлять join, чтобы получить страну этого бренда.

В реальной практике такие рассуждения будут верны?
Какие здесь будут рекомендации относительно первичных ключей (суррогатный vs. натурального)?




3) Смутила колонка price в таблице с исходными данными, так как после запятой указано очень много знаков.
Корректно ли при чтении денежных сумм из файла делать округление до двух знаков после запятой?



Спасибо! Очень жду обратную связь :)

